{"ast":null,"code":"//Function to hadnle quick sort algorithm \nexport function getQuickSortAnimation(array) {\n  //animation arrays that stores the bar that would change the colors\n  let animation = [];\n  let auxilaryArray = array.slice();\n  getQuickSort(auxilaryArray, 0, auxilaryArray.length - 1, animation);\n  return animation;\n}\n\nfunction getQuickSort(array, startIndex, endIndex, animation) {\n  var pivotIndex; //checking the bound: \n\n  if (startIndex < endIndex) {\n    //function to return the index of the pivot after each partition swap: \n    pivotIndex = partition(array, startIndex, endIndex, animation); //recursive call to sort the left and right partiion of the array: \n\n    getQuickSort(array, startIndex, pivotIndex - 1, animation); //sort the left partition of the array\n\n    getQuickSort(array, pivotIndex + 1, endIndex, animation); //sort the right partition of the array\n  }\n} //Helper Method to partition the two sides of the array: \n\n\nfunction partition(array, left, right, animation) {\n  //assume the pivot element is the last element in the array:\n  let pivot = array[right]; //move the pointers along the array\n\n  for (let i = left; i <= right - 1; i++) {\n    //push these values to change its color\n    animation.push([i, right]); //push the same values again to reset its color\n\n    animation.push([i, right]);\n\n    if (array[i] <= pivot) {\n      //swap these two heights:\n      animation.push([i, array[left]]);\n      animation.push([left, array[i]]);\n      swap(array, i, left);\n    }\n  } //the pivot should (ideally) be on the left side at the end of the algorithm \n\n\n  return left;\n} //function to swap element: \n\n\nfunction swap(array, left, right) {\n  let temp = array[left];\n  array[left] = array[right];\n  array[right] = temp;\n} //end of swap()","map":{"version":3,"sources":["/Users/willieluong/Desktop/sorting-visualizer/src/sortinalgorithms/QuickSort.js"],"names":["getQuickSortAnimation","array","animation","auxilaryArray","slice","getQuickSort","length","startIndex","endIndex","pivotIndex","partition","left","right","pivot","i","push","swap","temp"],"mappings":"AAAA;AACA,OAAO,SAASA,qBAAT,CAA+BC,KAA/B,EACP;AACI;AACA,MAAIC,SAAS,GAAG,EAAhB;AACA,MAAIC,aAAa,GAAGF,KAAK,CAACG,KAAN,EAApB;AACAC,EAAAA,YAAY,CAACF,aAAD,EAAgB,CAAhB,EAAmBA,aAAa,CAACG,MAAd,GAAuB,CAA1C,EAA6CJ,SAA7C,CAAZ;AACA,SAAOA,SAAP;AACH;;AAED,SAASG,YAAT,CAAsBJ,KAAtB,EAA6BM,UAA7B,EAAyCC,QAAzC,EAAmDN,SAAnD,EACA;AACI,MAAIO,UAAJ,CADJ,CAEI;;AACA,MAAGF,UAAU,GAAGC,QAAhB,EACA;AACI;AACAC,IAAAA,UAAU,GAAGC,SAAS,CAACT,KAAD,EAAQM,UAAR,EAAoBC,QAApB,EAA8BN,SAA9B,CAAtB,CAFJ,CAGI;;AACAG,IAAAA,YAAY,CAACJ,KAAD,EAAQM,UAAR,EAAoBE,UAAU,GAAG,CAAjC,EAAoCP,SAApC,CAAZ,CAJJ,CAIgE;;AAC5DG,IAAAA,YAAY,CAACJ,KAAD,EAAQQ,UAAU,GAAG,CAArB,EAAwBD,QAAxB,EAAkCN,SAAlC,CAAZ,CALJ,CAK6D;AAC5D;AACJ,C,CAED;;;AACA,SAASQ,SAAT,CAAmBT,KAAnB,EAA0BU,IAA1B,EAAgCC,KAAhC,EAAuCV,SAAvC,EACA;AACI;AACA,MAAIW,KAAK,GAAGZ,KAAK,CAACW,KAAD,CAAjB,CAFJ,CAGI;;AACA,OAAI,IAAIE,CAAC,GAAGH,IAAZ,EAAkBG,CAAC,IAAIF,KAAK,GAAG,CAA/B,EAAkCE,CAAC,EAAnC,EACA;AACI;AACAZ,IAAAA,SAAS,CAACa,IAAV,CAAe,CAACD,CAAD,EAAIF,KAAJ,CAAf,EAFJ,CAGI;;AACAV,IAAAA,SAAS,CAACa,IAAV,CAAe,CAACD,CAAD,EAAIF,KAAJ,CAAf;;AAEA,QAAGX,KAAK,CAACa,CAAD,CAAL,IAAYD,KAAf,EACA;AACI;AACAX,MAAAA,SAAS,CAACa,IAAV,CAAe,CAACD,CAAD,EAAIb,KAAK,CAACU,IAAD,CAAT,CAAf;AACAT,MAAAA,SAAS,CAACa,IAAV,CAAe,CAACJ,IAAD,EAAOV,KAAK,CAACa,CAAD,CAAZ,CAAf;AACAE,MAAAA,IAAI,CAACf,KAAD,EAAQa,CAAR,EAAWH,IAAX,CAAJ;AAGH;AACJ,GApBL,CAqBI;;;AACA,SAAOA,IAAP;AAEH,C,CAKD;;;AACA,SAASK,IAAT,CAAcf,KAAd,EAAqBU,IAArB,EAA2BC,KAA3B,EACA;AACI,MAAIK,IAAI,GAAGhB,KAAK,CAACU,IAAD,CAAhB;AACAV,EAAAA,KAAK,CAACU,IAAD,CAAL,GAAcV,KAAK,CAACW,KAAD,CAAnB;AACAX,EAAAA,KAAK,CAACW,KAAD,CAAL,GAAeK,IAAf;AAEH,C,CAAA","sourcesContent":["//Function to hadnle quick sort algorithm \nexport function getQuickSortAnimation(array)\n{\n    //animation arrays that stores the bar that would change the colors\n    let animation = [];\n    let auxilaryArray = array.slice();\n    getQuickSort(auxilaryArray, 0, auxilaryArray.length - 1, animation);\n    return animation;\n}\n\nfunction getQuickSort(array, startIndex, endIndex, animation)\n{\n    var pivotIndex; \n    //checking the bound: \n    if(startIndex < endIndex)\n    {\n        //function to return the index of the pivot after each partition swap: \n        pivotIndex = partition(array, startIndex, endIndex, animation);\n        //recursive call to sort the left and right partiion of the array: \n        getQuickSort(array, startIndex, pivotIndex - 1, animation); //sort the left partition of the array\n        getQuickSort(array, pivotIndex + 1, endIndex, animation) //sort the right partition of the array\n    }\n}\n\n//Helper Method to partition the two sides of the array: \nfunction partition(array, left, right, animation)\n{\n    //assume the pivot element is the last element in the array:\n    let pivot = array[right];\n    //move the pointers along the array\n    for(let i = left; i <= right - 1; i++)\n    {\n        //push these values to change its color\n        animation.push([i, right]);\n        //push the same values again to reset its color\n        animation.push([i, right]);\n\n        if(array[i] <= pivot)\n        {\n            //swap these two heights:\n            animation.push([i, array[left]]);\n            animation.push([left, array[i]]);\n            swap(array, i, left);\n            \n\n        }\n    }\n    //the pivot should (ideally) be on the left side at the end of the algorithm \n    return left;\n\n}\n\n\n\n\n//function to swap element: \nfunction swap(array, left, right)\n{\n    let temp = array[left];\n    array[left] = array[right];\n    array[right] = temp;\n\n}//end of swap()\n\n\n\n\n\n"]},"metadata":{},"sourceType":"module"}