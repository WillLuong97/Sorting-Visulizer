{"ast":null,"code":"//Function to hadnle quick sort algorithm \nexport function getQuickSortAnimation(array) {\n  //animation arrays that stores the bar that would change the colors\n  let animation = [];\n  let auxilaryArray = array.slice();\n  getQuickSort(auxilaryArray, 0, auxilaryArray.length - 1, animation);\n  return animation;\n} //Helper method to implement Quick Sort algorithm\n\nfunction getQuickSort(array, startIndex, endIndex, animation) {\n  let pivotIndex; //checking the bound: \n\n  if (startIndex < endIndex) {\n    //function to return the index of the pivot after each partition swap: \n    pivotIndex = partition(array, startIndex, endIndex, animation); //recursive call to sort the left and right partiion of the array: \n\n    getQuickSort(array, startIndex, pivotIndex - 1, animation); //sort the left partition of the array\n\n    getQuickSort(array, pivotIndex + 1, endIndex, animation); //sort the right partition of the array\n  }\n} //end of getQuickSort()\n//Helper Method to partition the two sides of the array: \n\n\nfunction partition(array, left, right, animation) {\n  //assume the pivot element is the last element in the array:\n  let pivot = array[right];\n  let pivotIndex = left; //move the pointers along the array\n\n  for (let i = left; i <= right - 1; i++) {\n    //push these values to change its color\n    animation.push([i, right]); //push the same values again to reset its color\n\n    animation.push([i, right]);\n\n    if (array[i] <= pivot) {\n      //swap these two heights:\n      animation.push([i, array[pivotIndex]]);\n      animation.push([pivotIndex, array[i]]);\n      swap(array, i, pivotIndex);\n      pivotIndex++;\n    } else {\n      //placeholders for the rest of the animation array: \n      animation.push([-1, -1]);\n      animation.push([-1. - 1]);\n    }\n\n    animation.push([-1. - 1]);\n    animation.push([-1. - 1]);\n  }\n\n  animation.push([-1. - 1]);\n  animation.push([-1. - 1]);\n  animation.push([-1. - 1]);\n  animation.push([-1. - 1]); //swap the two heights, if right side is lesser than the pivot\n\n  animation.push([pivotIndex, array[right]]);\n  animation.push([right, array[pivotIndex]]);\n  swap(array, pivotIndex, right); //the pivot should (ideally) be on the left side at the end of the algorithm \n\n  return left;\n} //function to swap element: \n\n\nfunction swap(array, left, right) {\n  let temp = array[left];\n  array[left] = array[right];\n  array[right] = temp;\n} //end of swap()","map":{"version":3,"sources":["/Users/willieluong/Desktop/sorting-visualizer/src/sortinalgorithms/QuickSort.js"],"names":["getQuickSortAnimation","array","animation","auxilaryArray","slice","getQuickSort","length","startIndex","endIndex","pivotIndex","partition","left","right","pivot","i","push","swap","temp"],"mappings":"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","sourcesContent":["//Function to hadnle quick sort algorithm \nexport function getQuickSortAnimation(array)\n{\n    //animation arrays that stores the bar that would change the colors\n    let animation = [];\n    let auxilaryArray = array.slice();\n    getQuickSort(auxilaryArray, 0, auxilaryArray.length - 1, animation);\n    return animation;\n\n}\n\n\n//Helper method to implement Quick Sort algorithm\nfunction getQuickSort(array, startIndex, endIndex, animation)\n{\n    let pivotIndex; \n    //checking the bound: \n    if(startIndex < endIndex)\n    {\n        //function to return the index of the pivot after each partition swap: \n        pivotIndex = partition(array, startIndex, endIndex, animation);\n        //recursive call to sort the left and right partiion of the array: \n        getQuickSort(array, startIndex, pivotIndex - 1, animation); //sort the left partition of the array\n        getQuickSort(array, pivotIndex + 1, endIndex, animation) //sort the right partition of the array\n    }\n}//end of getQuickSort()\n\n//Helper Method to partition the two sides of the array: \nfunction partition(array, left, right, animation)\n{\n    //assume the pivot element is the last element in the array:\n    let pivot = array[right];\n    let pivotIndex = left;\n    //move the pointers along the array\n    for(let i = left; i <= right - 1; i++)\n    {\n        //push these values to change its color\n        animation.push([i, right]);\n        //push the same values again to reset its color\n        animation.push([i, right]);\n\n        if(array[i] <= pivot)\n        {\n            //swap these two heights:\n            animation.push([i, array[pivotIndex]]);\n            animation.push([pivotIndex, array[i]]);\n            swap(array, i, pivotIndex);\n            pivotIndex++;\n\n        }\n\n        else{\n            //placeholders for the rest of the animation array: \n            animation.push([-1, -1]);\n            animation.push([-1. -1]);\n\n        }\n\n        animation.push([-1. -1]);\n        animation.push([-1. -1]);\n    }\n\n    animation.push([-1. -1]);\n    animation.push([-1. -1]);\n    animation.push([-1. -1]);\n    animation.push([-1. -1]);\n    //swap the two heights, if right side is lesser than the pivot\n    animation.push([pivotIndex, array[right]]);\n    animation.push([right, array[pivotIndex]]);\n    swap(array, pivotIndex, right);\n    //the pivot should (ideally) be on the left side at the end of the algorithm \n    return left;\n\n}\n\n//function to swap element: \nfunction swap(array, left, right)\n{\n    let temp = array[left];\n    array[left] = array[right];\n    array[right] = temp;\n\n}//end of swap()\n\n\n\n\n\n"]},"metadata":{},"sourceType":"module"}