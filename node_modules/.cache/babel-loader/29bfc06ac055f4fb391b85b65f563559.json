{"ast":null,"code":"//Function to hadnle quick sort algorithm \n// export function getQuickSortAnimation(array)\n// {\n//     quickSort(array, 0, (array.length - 1));\n// }\nexport function getQuickSort(array) {\n  const left = 0;\n  const right = array.length - 1; // //bound check: \n\n  if (left < right) {\n    return;\n  } //pick a pivot element in the array\n  //In this case, the pivot element will be the middle element for better time complexity\n\n\n  const pivot = array[(left + right) / 2]; //recursive call until the array of both the left side and right side of the element are sorted: \n  //partiion the left side and right side of the pivot element:\n\n  const index = partition(array, left, right, pivot);\n\n  if (left < pivot - 1) {\n    getQuickSort(array, left, index - 1); //sort the left partition of the array\n  }\n\n  if (right > pivot) {\n    getQuickSort(array, index, right); //sort the right partition of the array\n  }\n\n  console.log(array);\n  return array.concat(getQuickSort(array, left, index - 1), pivot, getQuickSort(array, index, right));\n} //Helper Method to partition the two sides of the array: \n\nfunction partition(array, left, right, pivot) {\n  //move the pointers along the array\n  while (left < right) {\n    // if the left side is lesser than the pivot, the left pointer will keep going until an element is out of place\n    while (array[left] < pivot) {\n      //keep moving right\n      left++;\n    } //if the right side is still greater than the pivot, then the right pointer will keep going until an element is out of place\n\n\n    while (array[right] > pivot) {\n      //keep going left\n      right--;\n    }\n\n    if (left <= right) {\n      swap(array, left, right);\n      left++;\n      right--;\n    }\n  } // end while loop\n  //the pivot should (ideally) be on the left side at the end of the algorithm \n\n\n  return left;\n} //function to swap element: \n\n\nfunction swap(array, left, right) {\n  let temp = array[left];\n  array[left] = array[right];\n  array[right] = temp;\n} //end of swap()","map":{"version":3,"sources":["/Users/willieluong/Desktop/sorting-visualizer/src/sortinalgorithms/QuickSort.js"],"names":["getQuickSort","array","left","right","length","pivot","index","partition","console","log","concat","swap","temp"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AAEA,OAAO,SAASA,YAAT,CAAsBC,KAAtB,EACP;AACI,QAAMC,IAAI,GAAG,CAAb;AACA,QAAMC,KAAK,GAAGF,KAAK,CAACG,MAAN,GAAe,CAA7B,CAFJ,CAGI;;AACA,MAAIF,IAAI,GAAGC,KAAX,EACA;AACI;AACH,GAPL,CASI;AACA;;;AACA,QAAME,KAAK,GAAGJ,KAAK,CAAC,CAACC,IAAI,GAAGC,KAAR,IAAiB,CAAlB,CAAnB,CAXJ,CAaI;AACA;;AACA,QAAMG,KAAK,GAAGC,SAAS,CAACN,KAAD,EAAQC,IAAR,EAAaC,KAAb,EAAoBE,KAApB,CAAvB;;AAEA,MAAGH,IAAI,GAAGG,KAAK,GAAG,CAAlB,EAAoB;AAChBL,IAAAA,YAAY,CAACC,KAAD,EAAQC,IAAR,EAAcI,KAAK,GAAG,CAAtB,CAAZ,CADgB,CACsB;AACzC;;AAED,MAAGH,KAAK,GAAGE,KAAX,EACA;AACIL,IAAAA,YAAY,CAACC,KAAD,EAAQK,KAAR,EAAeH,KAAf,CAAZ,CADJ,CACuC;AAEtC;;AACDK,EAAAA,OAAO,CAACC,GAAR,CAAYR,KAAZ;AAEA,SAAOA,KAAK,CAACS,MAAN,CAAaV,YAAY,CAACC,KAAD,EAAQC,IAAR,EAAcI,KAAK,GAAG,CAAtB,CAAzB,EAAmDD,KAAnD,EAA0DL,YAAY,CAACC,KAAD,EAAQK,KAAR,EAAeH,KAAf,CAAtE,CAAP;AACH,C,CAED;;AACA,SAASI,SAAT,CAAmBN,KAAnB,EAA0BC,IAA1B,EAAgCC,KAAhC,EAAuCE,KAAvC,EACA;AACI;AACA,SAAQH,IAAI,GAAGC,KAAf,EACA;AACI;AACA,WAAMF,KAAK,CAACC,IAAD,CAAL,GAAcG,KAApB,EACA;AACI;AACAH,MAAAA,IAAI;AACP,KANL,CAQI;;;AACA,WAAMD,KAAK,CAACE,KAAD,CAAL,GAAeE,KAArB,EACA;AACI;AACAF,MAAAA,KAAK;AACR;;AAED,QAAID,IAAI,IAAIC,KAAZ,EACA;AACIQ,MAAAA,IAAI,CAACV,KAAD,EAAQC,IAAR,EAAcC,KAAd,CAAJ;AACAD,MAAAA,IAAI;AACJC,MAAAA,KAAK;AACR;AACJ,GAxBL,CAwBK;AAED;;;AACA,SAAOD,IAAP;AAEH,C,CAKD;;;AACA,SAASS,IAAT,CAAcV,KAAd,EAAqBC,IAArB,EAA2BC,KAA3B,EACA;AACI,MAAIS,IAAI,GAAGX,KAAK,CAACC,IAAD,CAAhB;AACAD,EAAAA,KAAK,CAACC,IAAD,CAAL,GAAcD,KAAK,CAACE,KAAD,CAAnB;AACAF,EAAAA,KAAK,CAACE,KAAD,CAAL,GAAeS,IAAf;AAEH,C,CAAA","sourcesContent":["//Function to hadnle quick sort algorithm \n// export function getQuickSortAnimation(array)\n// {\n//     quickSort(array, 0, (array.length - 1));\n// }\n\nexport function getQuickSort(array)\n{\n    const left = 0;\n    const right = array.length - 1; \n    // //bound check: \n    if (left < right)\n    {\n        return;\n    }\n\n    //pick a pivot element in the array\n    //In this case, the pivot element will be the middle element for better time complexity\n    const pivot = array[(left + right) / 2];\n    \n    //recursive call until the array of both the left side and right side of the element are sorted: \n    //partiion the left side and right side of the pivot element:\n    const index = partition(array, left,right, pivot);\n    \n    if(left < pivot - 1){\n        getQuickSort(array, left, index - 1); //sort the left partition of the array\n    }\n\n    if(right > pivot)\n    {\n        getQuickSort(array, index, right); //sort the right partition of the array\n\n    }\n    console.log(array);\n\n    return array.concat(getQuickSort(array, left, index - 1), pivot, getQuickSort(array, index, right));\n}\n\n//Helper Method to partition the two sides of the array: \nfunction partition(array, left, right, pivot)\n{\n    //move the pointers along the array\n    while ( left < right)\n    {\n        // if the left side is lesser than the pivot, the left pointer will keep going until an element is out of place\n        while(array[left] < pivot)\n        {\n            //keep moving right\n            left++; \n        }\n\n        //if the right side is still greater than the pivot, then the right pointer will keep going until an element is out of place\n        while(array[right] > pivot)\n        {\n            //keep going left\n            right--; \n        }\n\n        if (left <= right)\n        {\n            swap(array, left, right);\n            left++;\n            right--;\n        }\n    }// end while loop\n\n    //the pivot should (ideally) be on the left side at the end of the algorithm \n    return left;\n\n}\n\n\n\n\n//function to swap element: \nfunction swap(array, left, right)\n{\n    let temp = array[left];\n    array[left] = array[right];\n    array[right] = temp;\n\n}//end of swap()\n\n\n\n\n\n"]},"metadata":{},"sourceType":"module"}