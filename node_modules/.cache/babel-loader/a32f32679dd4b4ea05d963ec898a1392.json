{"ast":null,"code":"// //Function to hadnle quick sort algorithm \n// export function getQuickSortAnimation(array)\n// {\n//     //animation arrays that stores the bar that would change the colors\n//     let animation = [];\n//     let auxilaryArray = array.slice();\n//     getQuickSort(auxilaryArray, 0, auxilaryArray.length - 1, animation);\n//     return animation;\n// }\n// //Helper method to implement Quick Sort algorithm\n// function getQuickSort(array, startIndex, endIndex, animation)\n// {\n//     let pivotIndex; \n//     //checking the bound: \n//     if(startIndex < endIndex)\n//     {\n//         //function to return the index of the pivot after each partition swap: \n//         pivotIndex = partition(array, startIndex, endIndex, animation);\n//         //recursive call to sort the left and right partiion of the array: \n//         getQuickSort(array, startIndex, pivotIndex - 1, animation); //sort the left partition of the array\n//         getQuickSort(array, pivotIndex + 1, endIndex, animation) //sort the right partition of the array\n//     }\n// }//end of getQuickSort()\n// //Helper Method to partition the two sides of the array: \n// function partition(array, left, right, animation)\n// {\n//     //assume the pivot element is the last element in the array:\n//     let pivot = array[right];\n//     //move the pointers along the array\n//     for(let i = left; i <= right - 1; i++)\n//     {\n//         //push these values to change its color\n//         animation.push([i, right]);\n//         //push the same values again to reset its color\n//         animation.push([i, right]);\n//         if(array[i] <= pivot)\n//         {\n//             //swap these two heights:\n//             animation.push([i, array[left]]);\n//             animation.push([left, array[i]]);\n//             swap(array, i, left);\n//             left++;\n//         }\n//         else{\n//             //placeholders for the rest of the animation array: \n//             animation.push([-1, -1]);\n//             animation.push([-1. -1]);\n//         }\n//         animation.push([-1. -1]);\n//         animation.push([-1. -1]);\n//     }\n//     animation.push([-1. -1]);\n//     animation.push([-1. -1]);\n//     animation.push([-1. -1]);\n//     animation.push([-1. -1]);\n//     //swap the two heights, if right side is lesser than the pivot\n//     animation.push([left, array[right]]);\n//     animation.push([right, array[left]]);\n//     swap(array, left, right);\n//     //the pivot should (ideally) be on the left side at the end of the algorithm \n//     return left;\n// }\n// //function to swap element: \n// function swap(array, left, right)\n// {\n//     let temp = array[left];\n//     array[left] = array[right];\n//     array[right] = temp;\n// }//end of swap()\nexport function getQuickSortAnimation(array) {\n  let animations = [];\n  let auxillaryArray = array.slice();\n  quickSort(auxillaryArray, 0, auxillaryArray.length - 1, animations);\n  array = auxillaryArray;\n  return [animations, array];\n}\n\nfunction quickSort(auxillaryArray, startIndex, endIndex, animations) {\n  let pivotIndex;\n\n  if (startIndex < endIndex) {\n    pivotIndex = partitionArray(auxillaryArray, startIndex, endIndex, animations);\n    quickSort(auxillaryArray, startIndex, pivotIndex - 1, animations);\n    quickSort(auxillaryArray, pivotIndex + 1, endIndex, animations);\n  }\n}\n\nfunction partitionArray(auxillaryArray, startIndex, endIndex, animations) {\n  let pivot = auxillaryArray[endIndex];\n  let pivotIndex = startIndex;\n\n  for (let i = startIndex; i <= endIndex - 1; i++) {\n    animations.push([i, endIndex]);\n    animations.push([i, endIndex]);\n\n    if (auxillaryArray[i] <= pivot) {\n      //Swap these two heights\n      animations.push([i, auxillaryArray[pivotIndex]]);\n      animations.push([pivotIndex, auxillaryArray[i]]);\n      swap(auxillaryArray, i, pivotIndex);\n      pivotIndex++;\n    } else {\n      animations.push([-1, -1]);\n      animations.push([-1, -1]);\n    }\n\n    animations.push([-1, -1]);\n    animations.push([-1, -1]);\n  }\n\n  animations.push([-1, -1]);\n  animations.push([-1, -1]);\n  animations.push([-1, -1]);\n  animations.push([-1, -1]); //Swap these two heights\n\n  animations.push([pivotIndex, auxillaryArray[endIndex]]);\n  animations.push([endIndex, auxillaryArray[pivotIndex]]);\n  swap(auxillaryArray, pivotIndex, endIndex);\n  return pivotIndex;\n}\n\nfunction swap(auxillaryArray, firstIndex, secondIndex) {\n  let temp = auxillaryArray[firstIndex];\n  auxillaryArray[firstIndex] = auxillaryArray[secondIndex];\n  auxillaryArray[secondIndex] = temp;\n}\n\nfunction arraysAreEqual(firstArray, secondArray) {\n  if (firstArray.length !== secondArray.length) {\n    return false;\n  }\n\n  for (let i = 0; i < firstArray.length; i++) {\n    if (firstArray[i] !== secondArray[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}","map":{"version":3,"sources":["/Users/willieluong/Desktop/sorting-visualizer/src/sortinalgorithms/QuickSort.js"],"names":["getQuickSortAnimation","array","animations","auxillaryArray","slice","quickSort","length","startIndex","endIndex","pivotIndex","partitionArray","pivot","i","push","swap","firstIndex","secondIndex","temp","arraysAreEqual","firstArray","secondArray"],"mappings":"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","sourcesContent":["// //Function to hadnle quick sort algorithm \n// export function getQuickSortAnimation(array)\n// {\n//     //animation arrays that stores the bar that would change the colors\n//     let animation = [];\n//     let auxilaryArray = array.slice();\n//     getQuickSort(auxilaryArray, 0, auxilaryArray.length - 1, animation);\n//     return animation;\n\n// }\n\n\n// //Helper method to implement Quick Sort algorithm\n// function getQuickSort(array, startIndex, endIndex, animation)\n// {\n//     let pivotIndex; \n//     //checking the bound: \n//     if(startIndex < endIndex)\n//     {\n//         //function to return the index of the pivot after each partition swap: \n//         pivotIndex = partition(array, startIndex, endIndex, animation);\n//         //recursive call to sort the left and right partiion of the array: \n//         getQuickSort(array, startIndex, pivotIndex - 1, animation); //sort the left partition of the array\n//         getQuickSort(array, pivotIndex + 1, endIndex, animation) //sort the right partition of the array\n//     }\n// }//end of getQuickSort()\n\n// //Helper Method to partition the two sides of the array: \n// function partition(array, left, right, animation)\n// {\n//     //assume the pivot element is the last element in the array:\n//     let pivot = array[right];\n//     //move the pointers along the array\n//     for(let i = left; i <= right - 1; i++)\n//     {\n//         //push these values to change its color\n//         animation.push([i, right]);\n//         //push the same values again to reset its color\n//         animation.push([i, right]);\n\n//         if(array[i] <= pivot)\n//         {\n//             //swap these two heights:\n//             animation.push([i, array[left]]);\n//             animation.push([left, array[i]]);\n//             swap(array, i, left);\n//             left++;\n//         }\n//         else{\n//             //placeholders for the rest of the animation array: \n//             animation.push([-1, -1]);\n//             animation.push([-1. -1]);\n//         }\n\n//         animation.push([-1. -1]);\n//         animation.push([-1. -1]);\n//     }\n\n//     animation.push([-1. -1]);\n//     animation.push([-1. -1]);\n//     animation.push([-1. -1]);\n//     animation.push([-1. -1]);\n//     //swap the two heights, if right side is lesser than the pivot\n//     animation.push([left, array[right]]);\n//     animation.push([right, array[left]]);\n//     swap(array, left, right);\n//     //the pivot should (ideally) be on the left side at the end of the algorithm \n//     return left;\n\n// }\n\n// //function to swap element: \n// function swap(array, left, right)\n// {\n//     let temp = array[left];\n//     array[left] = array[right];\n//     array[right] = temp;\n\n// }//end of swap()\n\n\n\n\n\nexport function getQuickSortAnimation(array) {\n    let animations  = [];\n    let auxillaryArray = array.slice();\n    quickSort(auxillaryArray, 0, auxillaryArray.length - 1, animations);\n    array = auxillaryArray;\n    return [animations, array];\n}\n\n\nfunction quickSort(auxillaryArray, startIndex, endIndex, animations) {\n    let pivotIndex;\n    if (startIndex < endIndex) {\n        pivotIndex = partitionArray(auxillaryArray, startIndex, endIndex, animations);\n        quickSort(auxillaryArray, startIndex, pivotIndex - 1, animations);\n        quickSort(auxillaryArray, pivotIndex + 1, endIndex, animations);\n    }\n}\n\nfunction partitionArray(auxillaryArray, startIndex, endIndex, animations) {\n    let pivot = auxillaryArray[endIndex];\n    let pivotIndex = startIndex;\n    for (let i = startIndex; i <= endIndex - 1; i++) {\n        animations.push([i, endIndex]);\n        animations.push([i, endIndex]);\n        if (auxillaryArray[i] <= pivot) {\n            //Swap these two heights\n            animations.push([i, auxillaryArray[pivotIndex]]);\n            animations.push([pivotIndex, auxillaryArray[i]]);\n            swap(auxillaryArray, i , pivotIndex);\n            pivotIndex++;\n        }\n        else {\n            animations.push([-1, -1]);\n            animations.push([-1, -1]);\n        }\n        animations.push([-1, -1]);\n        animations.push([-1, -1]);\n    }\n    animations.push([-1, -1]);\n    animations.push([-1, -1]);\n    animations.push([-1, -1]);\n    animations.push([-1, -1]);\n    //Swap these two heights\n    animations.push([pivotIndex, auxillaryArray[endIndex]]);\n    animations.push([endIndex, auxillaryArray[pivotIndex]]);\n    swap(auxillaryArray, pivotIndex, endIndex);\n    return pivotIndex;\n}\n\nfunction swap(auxillaryArray, firstIndex, secondIndex) {\n    let temp = auxillaryArray[firstIndex];\n    auxillaryArray[firstIndex] = auxillaryArray[secondIndex];\n    auxillaryArray[secondIndex] = temp;\n}\n\nfunction arraysAreEqual(firstArray, secondArray) {\n    if (firstArray.length !== secondArray.length) {\n        return false;\n    }\n    for (let i = 0; i < firstArray.length; i++) {\n      if (firstArray[i] !== secondArray[i]) {\n        return false;\n      }\n    }\n    return true;\n}"]},"metadata":{},"sourceType":"module"}