{"ast":null,"code":"//Function to hadnle quick sort algorithm \n// export function getQuickSortAnimation(array)\n// {\n//     quickSort(array, 0, (array.length - 1));\n// }\nexport function getQuickSort(origArray) {\n  // const left = 0;\n  // const right = array.length - 1; \n  // // //bound check: \n  // if (left < right)\n  // {\n  //     return;\n  // }\n  // //pick a pivot element in the array\n  // //In this case, the pivot element will be the middle element for better time complexity\n  // const pivot = array[(left + right) / 2];\n  // //recursive call until the array of both the left side and right side of the element are sorted: \n  // //partiion the left side and right side of the pivot element:\n  // const index = partition(array, left,right, pivot);\n  // if(left < pivot - 1){\n  //     getQuickSort(array, left, index - 1); //sort the left partition of the array\n  // }\n  // if(right > pivot)\n  // {\n  //     getQuickSort(array, index, right); //sort the right partition of the array\n  // }\n  // console.log(array);\n  // return array;\n  if (origArray.length <= 1) {\n    return origArray;\n  } else {\n    var left = [];\n    var right = [];\n    var newArray = [];\n    var pivot = origArray.pop();\n    var length = origArray.length;\n\n    for (var i = 0; i < length; i++) {\n      if (origArray[i] <= pivot) {\n        left.push(origArray[i]);\n      } else {\n        right.push(origArray[i]);\n      }\n    }\n\n    return newArray.concat(getQuickSort(left), pivot, getQuickSort(right));\n  }\n} //Helper Method to partition the two sides of the array: \n\nfunction partition(array, left, right, pivot) {\n  //move the pointers along the array\n  while (left < right) {\n    // if the left side is lesser than the pivot, the left pointer will keep going until an element is out of place\n    while (array[left] < pivot) {\n      //keep moving right\n      left++;\n    } //if the right side is still greater than the pivot, then the right pointer will keep going until an element is out of place\n\n\n    while (array[right] > pivot) {\n      //keep going left\n      right--;\n    }\n\n    if (left <= right) {\n      swap(array, left, right);\n      left++;\n      right--;\n    }\n  } // end while loop\n  //the pivot should (ideally) be on the left side at the end of the algorithm \n\n\n  return left;\n} //function to swap element: \n\n\nfunction swap(array, left, right) {\n  let temp = array[left];\n  array[left] = array[right];\n  array[right] = temp;\n} //end of swap()","map":{"version":3,"sources":["/Users/willieluong/Desktop/sorting-visualizer/src/sortinalgorithms/QuickSort.js"],"names":["getQuickSort","origArray","length","left","right","newArray","pivot","pop","i","push","concat","partition","array","swap","temp"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AAEA,OAAO,SAASA,YAAT,CAAsBC,SAAtB,EACP;AACI;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAGA,MAAIA,SAAS,CAACC,MAAV,IAAoB,CAAxB,EAA2B;AAC7B,WAAOD,SAAP;AACA,GAFE,MAEI;AAEN,QAAIE,IAAI,GAAG,EAAX;AACA,QAAIC,KAAK,GAAG,EAAZ;AACA,QAAIC,QAAQ,GAAG,EAAf;AACA,QAAIC,KAAK,GAAGL,SAAS,CAACM,GAAV,EAAZ;AACA,QAAIL,MAAM,GAAGD,SAAS,CAACC,MAAvB;;AAEA,SAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,MAApB,EAA4BM,CAAC,EAA7B,EAAiC;AAChC,UAAIP,SAAS,CAACO,CAAD,CAAT,IAAgBF,KAApB,EAA2B;AAC1BH,QAAAA,IAAI,CAACM,IAAL,CAAUR,SAAS,CAACO,CAAD,CAAnB;AACA,OAFD,MAEO;AACNJ,QAAAA,KAAK,CAACK,IAAN,CAAWR,SAAS,CAACO,CAAD,CAApB;AACA;AACD;;AAED,WAAOH,QAAQ,CAACK,MAAT,CAAgBV,YAAY,CAACG,IAAD,CAA5B,EAAoCG,KAApC,EAA2CN,YAAY,CAACI,KAAD,CAAvD,CAAP;AACA;AACD,C,CAED;;AACA,SAASO,SAAT,CAAmBC,KAAnB,EAA0BT,IAA1B,EAAgCC,KAAhC,EAAuCE,KAAvC,EACA;AACI;AACA,SAAQH,IAAI,GAAGC,KAAf,EACA;AACI;AACA,WAAMQ,KAAK,CAACT,IAAD,CAAL,GAAcG,KAApB,EACA;AACI;AACAH,MAAAA,IAAI;AACP,KANL,CAQI;;;AACA,WAAMS,KAAK,CAACR,KAAD,CAAL,GAAeE,KAArB,EACA;AACI;AACAF,MAAAA,KAAK;AACR;;AAED,QAAID,IAAI,IAAIC,KAAZ,EACA;AACIS,MAAAA,IAAI,CAACD,KAAD,EAAQT,IAAR,EAAcC,KAAd,CAAJ;AACAD,MAAAA,IAAI;AACJC,MAAAA,KAAK;AACR;AACJ,GAxBL,CAwBK;AAED;;;AACA,SAAOD,IAAP;AAEH,C,CAKD;;;AACA,SAASU,IAAT,CAAcD,KAAd,EAAqBT,IAArB,EAA2BC,KAA3B,EACA;AACI,MAAIU,IAAI,GAAGF,KAAK,CAACT,IAAD,CAAhB;AACAS,EAAAA,KAAK,CAACT,IAAD,CAAL,GAAcS,KAAK,CAACR,KAAD,CAAnB;AACAQ,EAAAA,KAAK,CAACR,KAAD,CAAL,GAAeU,IAAf;AAEH,C,CAAA","sourcesContent":["//Function to hadnle quick sort algorithm \n// export function getQuickSortAnimation(array)\n// {\n//     quickSort(array, 0, (array.length - 1));\n// }\n\nexport function getQuickSort(origArray)\n{\n    // const left = 0;\n    // const right = array.length - 1; \n    // // //bound check: \n    // if (left < right)\n    // {\n    //     return;\n    // }\n\n    // //pick a pivot element in the array\n    // //In this case, the pivot element will be the middle element for better time complexity\n    // const pivot = array[(left + right) / 2];\n    \n    // //recursive call until the array of both the left side and right side of the element are sorted: \n    // //partiion the left side and right side of the pivot element:\n    // const index = partition(array, left,right, pivot);\n    \n    // if(left < pivot - 1){\n    //     getQuickSort(array, left, index - 1); //sort the left partition of the array\n    // }\n\n    // if(right > pivot)\n    // {\n    //     getQuickSort(array, index, right); //sort the right partition of the array\n\n    // }\n    // console.log(array);\n    \n    // return array;\n\n\n    if (origArray.length <= 1) { \n\t\treturn origArray;\n\t} else {\n\n\t\tvar left = [];\n\t\tvar right = [];\n\t\tvar newArray = [];\n\t\tvar pivot = origArray.pop();\n\t\tvar length = origArray.length;\n\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tif (origArray[i] <= pivot) {\n\t\t\t\tleft.push(origArray[i]);\n\t\t\t} else {\n\t\t\t\tright.push(origArray[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn newArray.concat(getQuickSort(left), pivot, getQuickSort(right));\n\t}\n}\n\n//Helper Method to partition the two sides of the array: \nfunction partition(array, left, right, pivot)\n{\n    //move the pointers along the array\n    while ( left < right)\n    {\n        // if the left side is lesser than the pivot, the left pointer will keep going until an element is out of place\n        while(array[left] < pivot)\n        {\n            //keep moving right\n            left++; \n        }\n\n        //if the right side is still greater than the pivot, then the right pointer will keep going until an element is out of place\n        while(array[right] > pivot)\n        {\n            //keep going left\n            right--; \n        }\n\n        if (left <= right)\n        {\n            swap(array, left, right);\n            left++;\n            right--;\n        }\n    }// end while loop\n\n    //the pivot should (ideally) be on the left side at the end of the algorithm \n    return left;\n\n}\n\n\n\n\n//function to swap element: \nfunction swap(array, left, right)\n{\n    let temp = array[left];\n    array[left] = array[right];\n    array[right] = temp;\n\n}//end of swap()\n\n\n\n\n\n"]},"metadata":{},"sourceType":"module"}