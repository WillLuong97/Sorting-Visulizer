{"ast":null,"code":"import { create, all } from 'mathjs';\nimport * as numbers from 'numbers'; //function to handle the Heap sort\n\nexport function getHeapSortAnimation(array) {\n  //getting the array length: \n  let n = array.length;\n\n  for (let i = math.floor(n / 2); i >= 0; i -= 1) {\n    buildMaxHeap(array, i);\n  } //swap the largest element in the heap tree with the last element\n\n\n  for (let i = n - 1; i > 0; i--) {\n    //swap last with largest\n    swap(array, 0, i);\n    n--; //traverse the array backward\n\n    buildMaxHeap(array, 0);\n  }\n\n  return;\n} //fuction to build a max heap\n//max heap is a binary tree with parent nodes > child nodes\n\nfunction buildMaxHeap(array, index) {\n  const left = 2 * i + 1; //left side of the tree\n\n  const right = 2 * i + 2; //right side of the binary tree\n\n  let max = i; // we will assume max element to be current index from the array\n  //if the left most element is the largest, then it will be the max element\n\n  if (left < array.length && array[left] > array[max]) {\n    max = left;\n  } //if the right element is the largest, then it will be the max element of the tree\n\n\n  if (right < array.length && array[right] > array[max]) {\n    max = right;\n  }\n\n  if (max != i) {\n    swap(input, i, max);\n    buildMaxHeap(input, max);\n  }\n} //fucntion to swap two elements in an array\n\n\nfunction swap(array, first, second) {\n  let temp = array[first];\n  array[first] = array[second];\n  array[second] = temp;\n} //end of swap()","map":{"version":3,"sources":["/Users/willieluong/Desktop/sorting-visualizer/src/sortinalgorithms/heapSort.js"],"names":["create","all","numbers","getHeapSortAnimation","array","n","length","i","math","floor","buildMaxHeap","swap","index","left","right","max","input","first","second","temp"],"mappings":"AAAA,SAASA,MAAT,EAAiBC,GAAjB,QAA4B,QAA5B;AACA,OAAO,KAAKC,OAAZ,MAAyB,SAAzB,C,CAEA;;AACA,OAAO,SAASC,oBAAT,CAA8BC,KAA9B,EACP;AACI;AACA,MAAIC,CAAC,GAAGD,KAAK,CAACE,MAAd;;AAEA,OAAI,IAAIC,CAAC,GAAGC,IAAI,CAACC,KAAL,CAAWJ,CAAC,GAAG,CAAf,CAAZ,EAA+BE,CAAC,IAAG,CAAnC,EAAsCA,CAAC,IAAE,CAAzC,EACA;AACIG,IAAAA,YAAY,CAACN,KAAD,EAAQG,CAAR,CAAZ;AACH,GAPL,CASI;;;AACA,OAAI,IAAIA,CAAC,GAAGF,CAAC,GAAG,CAAhB,EAAmBE,CAAC,GAAG,CAAvB,EAA0BA,CAAC,EAA3B,EACA;AACI;AACAI,IAAAA,IAAI,CAACP,KAAD,EAAQ,CAAR,EAAWG,CAAX,CAAJ;AACAF,IAAAA,CAAC,GAHL,CAGS;;AAELK,IAAAA,YAAY,CAACN,KAAD,EAAQ,CAAR,CAAZ;AACH;;AAED;AAEH,C,CAED;AACA;;AACA,SAASM,YAAT,CAAsBN,KAAtB,EAA6BQ,KAA7B,EACA;AACI,QAAMC,IAAI,GAAG,IAAIN,CAAJ,GAAQ,CAArB,CADJ,CAC4B;;AACxB,QAAMO,KAAK,GAAG,IAAIP,CAAJ,GAAQ,CAAtB,CAFJ,CAE6B;;AACzB,MAAIQ,GAAG,GAAGR,CAAV,CAHJ,CAGiB;AAEb;;AACA,MAAGM,IAAI,GAAGT,KAAK,CAACE,MAAb,IAAuBF,KAAK,CAACS,IAAD,CAAL,GAAcT,KAAK,CAACW,GAAD,CAA7C,EACA;AAEIA,IAAAA,GAAG,GAAGF,IAAN;AACH,GAVL,CAYI;;;AACA,MAAGC,KAAK,GAAGV,KAAK,CAACE,MAAd,IAAwBF,KAAK,CAACU,KAAD,CAAL,GAAeV,KAAK,CAACW,GAAD,CAA/C,EACA;AACIA,IAAAA,GAAG,GAAGD,KAAN;AACH;;AAED,MAAIC,GAAG,IAAIR,CAAX,EAAc;AACVI,IAAAA,IAAI,CAACK,KAAD,EAAQT,CAAR,EAAWQ,GAAX,CAAJ;AACAL,IAAAA,YAAY,CAACM,KAAD,EAAQD,GAAR,CAAZ;AACH;AAEJ,C,CAGD;;;AACA,SAASJ,IAAT,CAAcP,KAAd,EAAqBa,KAArB,EAA4BC,MAA5B,EAAmC;AAC/B,MAAIC,IAAI,GAAGf,KAAK,CAACa,KAAD,CAAhB;AACAb,EAAAA,KAAK,CAACa,KAAD,CAAL,GAAeb,KAAK,CAACc,MAAD,CAApB;AACAd,EAAAA,KAAK,CAACc,MAAD,CAAL,GAAgBC,IAAhB;AACH,C,CAAA","sourcesContent":["import { create, all } from 'mathjs'\nimport * as numbers from 'numbers'\n\n//function to handle the Heap sort\nexport function getHeapSortAnimation(array)\n{\n    //getting the array length: \n    let n = array.length;\n\n    for(let i = math.floor(n / 2); i >=0; i-=1)\n    {\n        buildMaxHeap(array, i)\n    }\n\n    //swap the largest element in the heap tree with the last element\n    for(let i = n - 1; i > 0; i--)\n    {\n        //swap last with largest\n        swap(array, 0, i);\n        n--; //traverse the array backward\n\n        buildMaxHeap(array, 0)\n    }\n\n    return\n\n}\n\n//fuction to build a max heap\n//max heap is a binary tree with parent nodes > child nodes\nfunction buildMaxHeap(array, index)\n{\n    const left = 2 * i + 1; //left side of the tree\n    const right = 2 * i + 2; //right side of the binary tree\n    let max = i; // we will assume max element to be current index from the array\n\n    //if the left most element is the largest, then it will be the max element\n    if(left < array.length && array[left] > array[max])\n    {\n        \n        max = left;\n    }\n\n    //if the right element is the largest, then it will be the max element of the tree\n    if(right < array.length && array[right] > array[max])\n    {\n        max = right;\n    }\n\n    if (max != i) {\n        swap(input, i, max)\n        buildMaxHeap(input, max)\n    }\n\n}\n\n\n//fucntion to swap two elements in an array\nfunction swap(array, first, second){\n    let temp = array[first];\n    array[first] = array[second];\n    array[second] = temp;\n}//end of swap()"]},"metadata":{},"sourceType":"module"}