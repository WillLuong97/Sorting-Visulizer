{"ast":null,"code":"//Function to hadnle quick sort algorithm \nexport function getQuickSortAnimation(array) {\n  quickSort(array, 0, array.length - 1);\n}\n\nfunction quickSort(array, left, right) {\n  //bound check: \n  if (left < right) {\n    return;\n  } //pick a pivot element in the array\n  //In this case, the pivot element will be the middle element for better time complexity\n\n\n  var pivot = array[(left + right) / 2]; //partiion the left side and right side of the pivot element:\n\n  var index = partition(array, left, right, pivot); //recursive call until the array of both the left side and right side of the element are sorted: \n\n  quickSort(array, left, index - 1); //sort the left partition of the array\n\n  quickSort(array, index, right); //sort the right partition of the array\n} //Helper Method to partition the two sides of the array: \n\n\nfunction partition(array, left, right, pitvot) {\n  //move the pointers along the array\n  while (left <= right) {\n    // if the left side is lesser than the pivot, the left pointer will keep going until an element is out of place\n    while (array[left] < pivot) {\n      //keep moving right\n      left++;\n    } //if the right side is still greater than the pivot, then the right pointer will keep going until an element is out of place\n\n\n    while (array[right] > pivot) {\n      //keep going left\n      right--;\n    }\n\n    if (left <= right) {\n      swap(array, left, right);\n      left++;\n      right--;\n    }\n  } // end while loop\n  //the pivot should (ideally) be on the left side at the end of the algorithm \n\n\n  return left;\n} //function to swap element: \n\n\nfunction swap(array, left, right) {\n  let temp = array[left];\n}","map":{"version":3,"sources":["/Users/willieluong/Desktop/sorting-visualizer/src/sortinalgorithms/QuickSort.js"],"names":["getQuickSortAnimation","array","quickSort","length","left","right","pivot","index","partition","pitvot","swap","temp"],"mappings":"AAAA;AACA,OAAO,SAASA,qBAAT,CAA+BC,KAA/B,EACP;AACIC,EAAAA,SAAS,CAACD,KAAD,EAAQ,CAAR,EAAWA,KAAK,CAACE,MAAN,GAAe,CAA1B,CAAT;AACH;;AAED,SAASD,SAAT,CAAmBD,KAAnB,EAA0BG,IAA1B,EAAgCC,KAAhC,EACA;AACI;AACA,MAAID,IAAI,GAAGC,KAAX,EACA;AACI;AACH,GALL,CAOI;AACA;;;AACA,MAAIC,KAAK,GAAGL,KAAK,CAAC,CAACG,IAAI,GAAGC,KAAR,IAAiB,CAAlB,CAAjB,CATJ,CAUI;;AACA,MAAIE,KAAK,GAAGC,SAAS,CAACP,KAAD,EAAQG,IAAR,EAAaC,KAAb,EAAoBC,KAApB,CAArB,CAXJ,CAYI;;AACAJ,EAAAA,SAAS,CAACD,KAAD,EAAQG,IAAR,EAAcG,KAAK,GAAG,CAAtB,CAAT,CAbJ,CAauC;;AACnCL,EAAAA,SAAS,CAACD,KAAD,EAAQM,KAAR,EAAeF,KAAf,CAAT,CAdJ,CAcoC;AACnC,C,CAED;;;AACA,SAASG,SAAT,CAAmBP,KAAnB,EAA0BG,IAA1B,EAAgCC,KAAhC,EAAuCI,MAAvC,EACA;AACI;AACA,SAAQL,IAAI,IAAIC,KAAhB,EACA;AACI;AACA,WAAMJ,KAAK,CAACG,IAAD,CAAL,GAAcE,KAApB,EACA;AACI;AACAF,MAAAA,IAAI;AACP,KANL,CAQI;;;AACA,WAAMH,KAAK,CAACI,KAAD,CAAL,GAAeC,KAArB,EACA;AACI;AACAD,MAAAA,KAAK;AACR;;AAED,QAAID,IAAI,IAAIC,KAAZ,EACA;AACIK,MAAAA,IAAI,CAACT,KAAD,EAAQG,IAAR,EAAcC,KAAd,CAAJ;AACAD,MAAAA,IAAI;AACJC,MAAAA,KAAK;AACR;AACJ,GAxBL,CAwBK;AAED;;;AACA,SAAOD,IAAP;AAEH,C,CAKD;;;AACA,SAASM,IAAT,CAAcT,KAAd,EAAqBG,IAArB,EAA2BC,KAA3B,EACA;AACI,MAAIM,IAAI,GAAGV,KAAK,CAACG,IAAD,CAAhB;AAGH","sourcesContent":["//Function to hadnle quick sort algorithm \nexport function getQuickSortAnimation(array)\n{\n    quickSort(array, 0, array.length - 1);\n}\n\nfunction quickSort(array, left, right)\n{\n    //bound check: \n    if (left < right)\n    {\n        return;\n    }\n\n    //pick a pivot element in the array\n    //In this case, the pivot element will be the middle element for better time complexity\n    var pivot = array[(left + right) / 2];\n    //partiion the left side and right side of the pivot element:\n    var index = partition(array, left,right, pivot);\n    //recursive call until the array of both the left side and right side of the element are sorted: \n    quickSort(array, left, index - 1); //sort the left partition of the array\n    quickSort(array, index, right); //sort the right partition of the array\n}\n\n//Helper Method to partition the two sides of the array: \nfunction partition(array, left, right, pitvot)\n{\n    //move the pointers along the array\n    while ( left <= right)\n    {\n        // if the left side is lesser than the pivot, the left pointer will keep going until an element is out of place\n        while(array[left] < pivot)\n        {\n            //keep moving right\n            left++; \n        }\n\n        //if the right side is still greater than the pivot, then the right pointer will keep going until an element is out of place\n        while(array[right] > pivot)\n        {\n            //keep going left\n            right--; \n        }\n\n        if (left <= right)\n        {\n            swap(array, left, right);\n            left++;\n            right--;\n        }\n    }// end while loop\n\n    //the pivot should (ideally) be on the left side at the end of the algorithm \n    return left;\n\n}\n\n\n\n\n//function to swap element: \nfunction swap(array, left, right)\n{\n    let temp = array[left];\n    \n\n}\n\n\n\n\n\n"]},"metadata":{},"sourceType":"module"}